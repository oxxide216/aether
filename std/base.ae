;; Base
(let head [list] -> import 'head')
(let tail [list] -> import 'tail')
(let last [list] -> import 'last')
(let nth [list index] -> import 'nth')
(let len [collection] -> import 'len')
(let is-empty [list] -> import 'is-empty')
(let get-range [list begin end] -> import 'get-range')
(let exit [exit-code] -> import 'exit')
(let compile [code] -> import 'compile')
(let eval-compiled [bytecode] -> import 'eval-compiled')
(let eval [code] -> import 'eval')

;; Functional stuff
(let map [func list] -> import 'map')
(let filter [func list] -> import 'filter')
(let reduce [func accumulator list] -> import 'reduce')

;; String operations
(let split [str delimiter] -> import 'split')
(let sub-str [str begin end] -> import 'sub-str')
(let join [str filler] -> import 'join')
(let eat-str [str pattern] -> import 'eat-str')
(let eat-byte-64 [str] -> import 'eat-byte-64')
(let eat-byte-32 [str] -> import 'eat-byte-32')
(let eat-byte-16 [str] -> import 'eat-byte-16')
(let eat-byte-8 [str] -> import 'eat-byte-8')

;; Conversions
(let str-to-int [str] -> import 'str-to-int')
(let str-to-float [str] -> import 'str-to-float')
(let int-to-float [int] -> import 'int-to-float')
(let int-to-str [int] -> import 'int-to-str')
(let bool-to-int [bool] -> import 'bool-to-int')
(let bool-to-str [bool] -> import 'bool-to-str')
(let float-to-int [float] -> import 'float-to-int')
(let float-to-str [float] -> import 'float-to-str')
(let byte-64-to-str [int] -> import 'byte-64-to-str')
(let byte-32-to-str [int] -> import 'byte-32-to-str')
(let byte-16-to-str [int] -> import 'byte-16-to-str')
(let byte-8-to-str [int] -> import 'byte-8-to-str')

;; Math
(let add [a b] -> import 'add')
(let sub [a b] -> import 'sub')
(let mul [a b] -> import 'mul')
(let div [a b] -> import 'div')
(let mod [a b] -> import 'mod')

;; Advanced math
(let abs [num] -> import 'abs')
(let min [num] -> import 'min')
(let max [num] -> import 'max')
(let pow [num pow] -> import 'pow')
(let sqrt [num] -> import 'sqrt')
(let round [num] -> import 'round')

;; Comparisons
(let == [a b] -> import 'eq')
(let != [a b] -> import 'ne')
(let < [a b] -> import 'ls')
(let <= [a b] -> import 'le')
(let > [a b] -> import 'gt')
(let >= [a b] -> import 'ge')

;; Boolean
(let -and [a b] -> import 'and')
(let -or [a b] -> import 'or')
(let -xor [a b] -> import 'xor')
(let not [value] -> import 'not')

;; Logical
(let -land [a b] -> import 'logical-and')
(let -lor [a b] -> import 'logical-or')

;; Types
(let type [value] -> import 'type')
(let unit? [value] -> import 'is-unit')
(let list? [value] -> import 'is-list')
(let str? [value] -> import 'is-string')
(let int? [value] -> import 'is-int')
(let float? [value] -> import 'is-float')
(let bool? [value] -> import 'is-bool')
(let func? [value] -> import 'is-func')
(let record? [value] -> import 'is-record')

(macro -op [op args] ->
  (reduce [acc elem] -> (op acc elem) <> (head args) (tail args)))

(macro + [...args] ->
  (-op add [args]))

(macro - [...args] ->
  (-op sub [args]))

(macro * [...args] ->
  (-op mul [args]))

(macro / [...args] ->
  (-op div [args]))

(macro % [...args] ->
  (-op mod [args]))

(macro and [...args] ->
  (-op -and [args]))

(macro or [...args] ->
  (-op -or [args]))

(macro xor [...args] ->
  (-op -xor [args]))

(macro land [...args] ->
  (-op -land [args]))

(macro lor [...args] ->
  (-op -lor [args]))

(macro for [element in list ...body] ->
  (let -list list)
  (while -list
    (let element (head -list))
    body
    (set -list (tail -list))))
