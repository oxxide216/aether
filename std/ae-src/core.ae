; Base
(let head [list] -> import 'head')
(let tail [list] -> import 'tail')
(let last [list] -> import 'last')
(let get-at [collection key] -> import 'get-at')
(let set-at [collection key value] -> import 'set-at')
(let get-index [collection item] -> import 'get-index')
(let len [collection] -> import 'len')
(let get-range [list begin end] -> import 'get-range')
(let gen-range [begin end] -> import 'gen-range')
(let map [func list] -> import 'map')
(let filter [func list] -> import 'filter')
(let fold [func accumulator list] -> import 'fold')
(let sort [list] -> import 'sort')

; Conversions
(let to-str [value] -> import 'to-str')
(let byte-64-to-str [int] -> import 'byte-64-to-str')
(let byte-32-to-str [int] -> import 'byte-32-to-str')
(let byte-16-to-str [int] -> import 'byte-16-to-str')
(let byte-8-to-str [int] -> import 'byte-8-to-str')
(let to-int [str] -> import 'to-int')
(let to-float [int] -> import 'to-float')

; Math
(let + [a b] -> import 'add')
(let - [a b] -> import 'sub')
(let * [a b] -> import 'mul')
(let / [a b] -> import 'div')
(let % [a b] -> import 'mod')

; Comparisons
(let == [a b] -> import 'eq')
(let != [a b] -> import 'ne')
(let < [a b] -> import 'ls')
(let <= [a b] -> import 'le')
(let > [a b] -> import 'gt')
(let >= [a b] -> import 'ge')

; Boolean
(let and [a b] -> import 'and')
(let or [a b] -> import 'or')
(let xor [a b] -> import 'xor')
(let not [value] -> import 'not')

; Types
(let type [value] -> import 'type')
(let unit? [value] -> import 'is-unit')
(let list? [value] -> import 'is-list')
(let str? [value] -> import 'is-string')
(let int? [value] -> import 'is-int')
(let float? [value] -> import 'is-float')
(let bool? [value] -> import 'is-bool')
(let func? [value] -> import 'is-func')
(let dict? [value] -> import 'is-dict')

(let make-env [] -> import 'make-env')
(let compile [env code path] -> import 'compile')
(let eval-compiled [env bytecode] -> import 'eval-compiled')
(let eval [env code] -> import 'eval')

(let exit [exit-code] -> import 'exit')

(macro for [element in list ...body] ->
  (let -list list)
  (while -list
    (let element (head -list))
    body
    (set -list (tail -list))))
