; Base
(let head [list] -> import 'head')
(let tail [list] -> import 'tail')
(let last [list] -> import 'last')
(let get-nth [collection index] -> import 'get-nth')
(let set-nth [collection index value] -> import 'set-nth')
(let get-at [dict key] -> import 'get-at')
(let set-at [dict key value] -> import 'set-at')
(let len [collection] -> import 'len')
(let get-range [list begin end] -> import 'get-range')
(let map [func list] -> import 'map')
(let filter [func list] -> import 'filter')
(let fold [func accumulator list] -> import 'fold')

; Conversions
(let str-to-int [str] -> import 'str-to-int')
(let str-to-float [str] -> import 'str-to-float')
(let int-to-float [int] -> import 'int-to-float')
(let int-to-str [int] -> import 'int-to-str')
(let bool-to-int [bool] -> import 'bool-to-int')
(let bool-to-str [bool] -> import 'bool-to-str')
(let float-to-int [float] -> import 'float-to-int')
(let float-to-str [float] -> import 'float-to-str')
(let byte-64-to-str [int] -> import 'byte-64-to-str')
(let byte-32-to-str [int] -> import 'byte-32-to-str')
(let byte-16-to-str [int] -> import 'byte-16-to-str')
(let byte-8-to-str [int] -> import 'byte-8-to-str')

; Math
(let add [a b] -> import 'add')
(let sub [a b] -> import 'sub')
(let mul [a b] -> import 'mul')
(let div [a b] -> import 'div')
(let mod [a b] -> import 'mod')

; Comparisons
(let == [a b] -> import 'eq')
(let != [a b] -> import 'ne')
(let < [a b] -> import 'ls')
(let <= [a b] -> import 'le')
(let > [a b] -> import 'gt')
(let >= [a b] -> import 'ge')

; Boolean
(let binary-and [a b] -> import 'and')
(let binary-or [a b] -> import 'or')
(let binary-xor [a b] -> import 'xor')
(let not [value] -> import 'not')

; Types
(let type [value] -> import 'type')
(let unit? [value] -> import 'is-unit')
(let list? [value] -> import 'is-list')
(let str? [value] -> import 'is-string')
(let int? [value] -> import 'is-int')
(let float? [value] -> import 'is-float')
(let bool? [value] -> import 'is-bool')
(let func? [value] -> import 'is-func')
(let dict? [value] -> import 'is-dict')

(let printf [arg] -> import 'printf')
(let input-size [size] -> import 'input-size')
(let input [] -> import 'input')

(let get-args [] -> import 'get-args')
(let make-env [] -> import 'make-env')
(let compile [env code path] -> import 'compile')
(let eval-compiled [env bytecode] -> import 'eval-compiled')
(let eval [env code] -> import 'eval')
(let exit [exit-code] -> import 'exit')

(macro fold-op [op args] ->
  (fold [acc elem] -> (op acc elem) <> (head args) (tail args)))

(macro + [...args] ->
  (fold-op add [args]))

(macro - [...args] ->
  (fold-op sub [args]))

(macro * [...args] ->
  (fold-op mul [args]))

(macro / [...args] ->
  (fold-op div [args]))

(macro % [...args] ->
  (fold-op mod [args]))

(macro and [...args] ->
  (fold-op binary-and [args]))

(macro or [...args] ->
  (fold-op binary-or [args]))

(macro xor [...args] ->
  (fold-op binary-xor [args]))

(macro for [element in list ...body] ->
  (let -list list)
  (while -list
    (let element (head -list))
    body
    (set -list (tail -list))))

(macro print [...args] ->
  (printf [args]))

(macro println [...args] ->
  (printf [args '\n']))
