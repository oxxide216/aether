(use 'std/core')
(use 'std/base')
(use 'std/term')
(use 'std/str')
(use 'std/io')
(use 'std/log')

(use 'config')
(use 'module-loader')
(use 'args-parser')

(let args (get-args))

(let parsed (parse-args (tail args)))
(let parsed-args parsed::'args')
(let input-path (head parsed-args))
(let mode parsed::'mode')
(let output-path parsed::'output-path')
(let output-macros-path parsed::'output-macros-path')
(let include-paths (+ std-include-paths parsed::'include-paths'))
(let dce parsed::'dce')

(if (unit? input-path)
  (error 'Input file was not provided')
  (exit 1))

(let input-file-content (read-binary-file input-path))
(if (unit? input-file-content)
  (error 'Could not open file ' input-path)
  (exit 1))

(if (== (get-range input-file-content 0 2) (to-bytes '#!'))
  (let shebang-end (get-index input-file-content (to-bytes '\n')))
  (if shebang-end
    (set input-file-content (get-range input-file-content
                                       (+ shebang-end 1)
                                       (len input-file-content))))

  (if (unit? input-file-content)
    (exit 0)))

(if (== mode mode-default)
  (match (get-range input-file-content 0 4)
    (to-bytes 'ABC\0') => (set mode mode-eval-bytecode)
    (to-bytes 'ABM\0') => (set mode mode-eval-macros)))

(let env (make-env parsed-args))

(let core-content (load-module env 'core' core-paths))
(let base-content (load-module env 'base' base-paths))

(match mode
  mode-default => (eval env (to-str input-file-content)
                        input-path include-paths)
  mode-eval-bytecode => (eval-compiled env input-file-content)
  mode-eval-macros => (eval-macros env input-file-content)
  mode-compile-only =>
    (do
      (let content (join [core-content base-content (to-str input-file-content)] '\n'))
      (let compiled (compile env content input-path include-paths false))

      (let success (write-file output-path compiled::'compiled'))
      (if (not success)
        (panic 'Could not write to ' output-path)))
  mode-compile-macros-only =>
    (do
      (let content (to-str input-file-content))
      (let compiled (compile env content input-path include-paths true))

      (if (unit? compiled::'compiled-macros')
        (info 'No macros found in ' input-path)
       else
        (let success (write-file output-macros-path compiled::'compiled-macros'))
        (if (not success)
          (panic 'Could not write to ' output-macros-path)))))
